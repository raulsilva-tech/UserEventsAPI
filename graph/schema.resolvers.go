package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/raulsilva-tech/UserEventsAPI/graph/model"
	"github.com/raulsilva-tech/UserEventsAPI/internal/entity"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	user, err := entity.NewUser(input.Name, input.Email, input.Password, time.Now(), time.Now())
	if err != nil {
		return nil, err
	}
	err = r.UserDAO.Create(user)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:       user.Id.String(),
		Name:     user.Name,
		Email:    user.Email,
		Password: user.Password,
	}, nil
}

// CreateUserAddress is the resolver for the createUserAddress field.
func (r *mutationResolver) CreateUserAddress(ctx context.Context, input model.NewUserAddress) (*model.UserAddress, error) {
	userId, err := uuid.Parse(input.UserID)
	if err != nil {
		return nil, err
	}
	userAddress, err := entity.NewUserAddress(entity.User{Id: userId}, input.Cep)
	if err != nil {
		return nil, err
	}
	err = r.UserAddressDAO.Create(userAddress)
	if err != nil {
		return nil, err
	}

	return &model.UserAddress{
		ID:   userAddress.Id.String(),
		User: &model.User{ID: userAddress.User.Id.String()},
	}, nil
}

// CreateEventType is the resolver for the createEventType field.
func (r *mutationResolver) CreateEventType(ctx context.Context, input model.NewEventType) (*model.EventType, error) {
	et, err := entity.NewEventType(input.Description)
	if err != nil {
		return nil, err
	}
	err = r.EventTypeDAO.Create(et)
	if err != nil {
		return nil, err
	}

	return &model.EventType{
		ID:          et.Id.String(),
		Description: et.Description,
	}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.Event, error) {
	userId, err := uuid.Parse(input.UserID)
	if err != nil {
		return nil, err
	}
	etId, err := uuid.Parse(input.EventTypeID)
	if err != nil {
		return nil, err
	}
	event, err := entity.NewEvent(entity.User{Id: userId}, entity.EventType{Id: etId}, time.Now())
	if err != nil {
		return nil, err
	}
	err = r.EventDAO.Create(event)
	if err != nil {
		return nil, err
	}

	return &model.Event{
		ID:          event.Id.String(),
		User:        &model.User{ID: event.User.Id.String()},
		EventType:   &model.EventType{ID: event.EventType.Id.String()},
		PerformedAt: event.PerformedAt.String(),
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	userList, err := r.UserDAO.GetAll()
	if err != nil {
		return nil, err
	}

	var modelList []*model.User

	for _, user := range userList {

		modelUser := model.User{
			ID:       user.Id.String(),
			Name:     user.Name,
			Email:    user.Email,
			Password: user.Password,
		}
		modelList = append(modelList, &modelUser)
	}

	return modelList, nil
}

// EventTypes is the resolver for the eventTypes field.
func (r *queryResolver) EventTypes(ctx context.Context) ([]*model.EventType, error) {
	recordList, err := r.EventTypeDAO.GetAll()
	if err != nil {
		return nil, err
	}

	var modelList []*model.EventType

	for _, record := range recordList {

		modelObj := model.EventType{
			ID:          record.Id.String(),
			Description: record.Description,
		}
		modelList = append(modelList, &modelObj)
	}

	return modelList, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context) ([]*model.Event, error) {
	recordList, err := r.EventDAO.GetAll()
	if err != nil {
		return nil, err
	}

	var modelList []*model.Event

	for _, record := range recordList {

		modelObj := model.Event{
			ID:          record.Id.String(),
			User:        &model.User{ID: record.User.Id.String()},
			EventType:   &model.EventType{ID: record.EventType.Id.String()},
			PerformedAt: record.PerformedAt.String(),
		}
		modelList = append(modelList, &modelObj)
	}

	return modelList, nil
}

// UserAddresses is the resolver for the userAddresses field.
func (r *queryResolver) UserAddresses(ctx context.Context) ([]*model.UserAddress, error) {
	recordList, err := r.UserAddressDAO.GetAll()
	if err != nil {
		return nil, err
	}

	var modelList []*model.UserAddress

	for _, record := range recordList {

		modelObj := model.UserAddress{
			ID:   record.Id.String(),
			User: &model.User{ID: record.User.Id.String()},
			Cep:  record.CEP,
		}
		modelList = append(modelList, &modelObj)
	}

	return modelList, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
